package 거의최단경로_5719;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.StringTokenizer;

public class Main {
	
	static int N, M;
	static int S, D;
	static int MAX_N = 500, MAX_M = 10000;
	static int a, b, w;
	static boolean[] visited;
	static List<Route> adj[];;

	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st;
		
		adj = new List[MAX_N];
		for (int i = 0; i < 500; i++) {
			adj[i] = new ArrayList<>();
		}
		visited = new boolean[MAX_N];
		
		while (true) {
			st = new StringTokenizer(br.readLine());
			
			N = Integer.parseInt(st.nextToken());
			M = Integer.parseInt(st.nextToken());
			if (N == 0 && M == 0) break;
			
			for (int i = 0; i < N; i++) {
				
				Collections.fill(adj[i], null);
			}
			
			st = new StringTokenizer(br.readLine());
			
			S = Integer.parseInt(st.nextToken());
			D = Integer.parseInt(st.nextToken());
			
			for (int i = 0; i < M; i++) {
				st = new StringTokenizer(br.readLine());
				
				a = Integer.parseInt(st.nextToken());
				b = Integer.parseInt(st.nextToken());
				w = Integer.parseInt(st.nextToken());
				
				adj[i].add(new Route(a, b, w));
			}
			
			int firstMinValue = dijkstra(S, D);
			
			
			
		}
	
	}
	
	static void removeMinPath(int foundValue, int currValue, int node, int S, int D) {
		
		// 1. 체크인
		
		// 2. 목적지인가 ?
		if (currValue == foundValue && node == S) 
		
		
	}
	
	static int dijkstra(int S, int D) {
		PriorityQueue<Route> queue = new PriorityQueue<>(Comparator.comparingInt(Route::getW));
		queue.add(new Route(0, S, 0));
		Arrays.fill(visited, false);
		
		int minPath = 0;
		int findCount = 0;
		while (!queue.isEmpty()) {
			Route curr = queue.poll();
			if (visited[curr.b] == true) continue;
			
			visited[curr.b] = true;
			minPath += curr.w;
			findCount++;
			
			if (findCount == N) break;
			
			
			for (Route next : adj[curr.b]) {
				if (visited[next.b] == false) { 
					queue.add(next);
				}
			}
		}
		return minPath;
	}
	
}

class Route {
	int a, b, w;
	
	public Route(int a, int b, int w) {
		this.a = a;
		this.b = b;
		this.w = w;
	}
	
	public int getW() {
		return this.w;
	}
}
